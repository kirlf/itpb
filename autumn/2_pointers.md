# Основы языка C: указатели, работа с памятью

## Указатели

Указатель – это переменная, содержащая адрес другой переменной. Оперируя указателями, вы подсказываете электронной вычислительной машине (ЭВМ), где взть данные, вместо того, чтобы заставлять ее эти данные постоянно копировать. Такой подход значительно ускоряет время выполнения программ.

Задать указатель можно с помощью оператора **разыменовывания** `*`:

```sh
<тип данных переменной, на которую будет указывать указатель> * <имя указателя>;
```

Например, так:

```c
float *a; # указатель на число с плавающей точкой
int *b; # указатель на целое число 
```

Получить адрес переменной можно с помощью оператора **взятия адреса** `&`:

```c
int A = 100; # целочисленная переменная
int *p; # указатель на целочисленную переменную
p = &A; # присвоение указателю адреса пременной А
```

В качестве примера из реальной жизни переменную `int A` можно представлять, допустим, как дом, а переменную `int *p` - как адрес этого дома. 

<img src="https://habrastorage.org/webt/qv/_-/8g/qv_-8gzavf58hfrkpz2qkqle26s.png" width="600"/>

*Рис. 1. Аналогия из реальной жизни для термина указатель.*

Отметим важную деталь: **указатель всегда хранит адрес первого байта пременной!** 

Как же тогда ЭВМ понимает, сколько байт нужно будет взять по указанному адресу? Тип данных переменной, адрес которой хранится в качестве указателя, явно сообщает ЭВМ, сколько байт эта переменная будет занимать. Соответвенно, зная адрес первого байта, хранящегося в качестве указателя, ЭВМ без труда отсчитывает нужное ей количество байт, соответсующее типу данных. 

Указатели могут указывать и на структуры. 

Допустим, у нас есть структура следующего вида:

```c
struct point{
int x;
int y;
};
```

Указатель на такую структуру будет выглядеть следующим образом:

```c
struct point * p_point;
```

Обращение к элементам структуры через указатель осуществляется с помощью оператора `->` (рис. ):

<img src="https://habrastorage.org/webt/ls/im/rg/lsimrgddskmkk8v8dccktkvst30.png" width="600"/>

*Рис. 2. Скрин-шот примера работы со структурами напрямую и через указатели.*

Кстати, указатели могут выступать в том числе и в качестве аргументов функций.

**[Керниган, Ричи]**:
- "5.1 Указатели и адреса";
- "5.2 Указатели и аргументы функций";
- "5.11 Указатели на функции".

## Массивы

Понятие массива в языке С неразрывно связано с понятием указателя и адресацией.

Задаются массивы с помощью следующего синтаксиса:

```sh
<тип данных элементов> <имя массива>[<максимальное количество элементов>];
```

Приведем пример массива целочисленных значений:

```c
int arr[] = {1, 2, 3}; // если элементы присваиваются сразу, то размер массива можно не указывать
```

**Снова отметим важную деталь**: непосредственно переменная ```arr``` хранит первый байт первого элемента. 

Однако, когда вы захотите распечатать элемент массива по индексу (допустим, с помощью функции `printf("%d", arr[1])`), ЭВМ (а точнее компилятор) распознает квадратные скобки, поймет, что вы имеете ввиду массив и в данном случае выведет вам 2.

"Под капотом" `arr[1]` равносильно `*(arr + 1)`. Иначе говоря, обращение к элементу по индексу - это ссылка на элемент, смещенный от первого байта первого элемента на номер индекса, умноженного на размер одного элемента в байтах.  

**Именно поэтому индексация во всех Си-подобных языках начинается с нуля!** Такой подход к рассмотрению индексов и указателей называется *адресной арифметикой*.

> Может показаться странным, но такая запись тоже будет верной:
>
> ```c
>  1[arr]
> ```
> В данном случае работает знакомое арифметическое правило - от престановки слагаемых сумма не меняется: 
>
> `arr[1] = *(arr + 1) = *(1 + arr) = 1[arr]`.
>
> Однако, в целях сохранения читаемости такой код лучше не писать.

Массивы могут быть в том чиле и многомерными. С точки зрения памяти такие массивы представляют из себя ничто иное как массивы указателей (возможно, на массивы других указателей - зависит от необходимой размерности).

**[Керниган, Ричи]**:
- "1.6 Массивы";
- "5.3 Указатели и массивы";
- "5.4 Адресная арифметика";
- "5.6 Массивы указателей и указатели на указатели";
- "5.7 Многомерные массивы";
- "5.8 Инициализация массивов указателей";
- "5.9 Указатели и многомерные массивы".

## Строки

В языке С строки – это массивы символов (тип данных `char`).

Задавать их можно либо с помощью *строковых констант* (через указатель):

```c
char * str = “Hello, World!”;
```

Либо с помощью синтаксиса массивов:

```c
char str[] = “Hello, World!”;
```

Две эти записи **не** равносильны между собой с точки зрения обращения к памяти, но об этом позже.

В памяти строка представляет примерно следующий вид (рис. 3):

<img src="https://habrastorage.org/webt/qj/ry/n_/qjryn_0umklcsrowqpsp3ey7b90.png" width="600"/>

*Рис. 3. Представление строк языка С в памяти.*

Обратите внимание на последний символ: `\0` - именно по нему ЭВМ понимает, что строка окончена.

Кстати, функция `main()` может принимать аргументы командной строки:

```c
// main.c
int main(int argc, char **argv)
{
return 0;
}
```

- `int argc` - хранит количество общее количество аргументов командной строки;
- `char ** argv` - хранит указатель, на массив символов (то есть перед нами вариант задания массива строк).

В нулевой позиции переменной `argv` всегда содержиться имя исполняемого файла. То есть, если, например, мы выполним такую команду:

```sh
$ gcc main.c -o execute_file
$./execute_file hello
```

то слово `hello` будет содержаться в `argv[1]`.

**[Керниган, Ричи]**:
- "1.9 Массивы символов";
- "5.5 Символьные указатели и функции";
- "5.10 Аогументы командной строки".

## Память: автоматическая, статическая, динамическая

Оперируя с переменными и функциями, вы неизбежно взаимодействуете с памятью ЭВМ, даже если об этом не задумываетесь. 

<img src="https://habrastorage.org/webt/v6/3h/i_/v63hi_octznkpgs4ygyzzekgeni.png" />

*Рис. 4. Скрин-шот иллюстрации организации памяти ЭВМ [2, c. 70].*

Рассмотрим доступные варианты.

### 1. Автоматическое выделение памяти

Задавая переменные внутри функций или же вызывая другие функции, ЭВМ **автоматически** выделяет в определенном участке организованной в виде **стека** памяти нужное количество байт и так же автоматически очищает данный участок памяти, когда функции заканчивают свою работу. Размер такого стека, как правило, равен примерно 2-3 мегабайтам.

### 2. Статическое выделение памяти

Если вы используете ключевое слово `static` перед заданием переменной внутри функции или зададите переменную в области видимости файла (вне какой-либо функции) в качестве констаты (то есть без вычислений), то такие переменные попадают в отдельную область - в **статическую** память. Такой подход гарантирует вам сохранность тех переменных, которые должны оставаться неизменными.

### 3. Динамическое выделение памяти

Если вы не знаете заранее, какое вам нужно количество памяти, и при этом вы не хотите тратиться на "запас", то необходимое количество байт можно выделить (аллоцировать) в ходе выполнения программы **динамически**. Область памяти, которая будет при этом задействована, называется **куча (heap)**, равная условно всей имеющейся на ЭВМ оперативной памяти.

> Термин куча в отношении памяти не имеет почти ничего общего с термином куча, обозначающим древовидную структуру данных!

Чтобы выделить необходимую вам память динамически, вы можете использовать функции **[malloc()](http://cppstudio.com/post/856/)**, **[calloc](http://cppstudio.com/post/846/)** и **[realloc](http://cppstudio.com/post/860/)**. Обратите внимание, что в данном случае никто не освободит память за вас! Такие упущения называются *утечками памяти (memory leakage)* и могут нарушить работу программы (и других процессов ЭВМ), когда доступная память закончится. Поэтому не забывайте использовать функцию **[free()](http://cppstudio.com/post/850/)** для освобождения больше не используемой памяти.

## Еще немного о строках

А теперь, когда мы знаем про разные способы работы с памятью, вернемся к примеру, с двумя подходами задания строк. Чем различаются записи `char str[] = "Hello, World!"` и `char * str = "Hello, World!"`? Все очень просто: они храняться в разных участках памяти. Первый вариант аллоцируется автоматически и поэтому изменяем; второй вариант является константой и неизменяем.

В целом, тема указателей сложна только в первом приближении. Систематическая работа с ними сформирует рано или поздно нужные нейронные связи (и привычку) и вы не сможете отказать себе в удовольствии заметить, что указатели - это не такая уж и сложная тема!..

 # Список использованной литературы
 
 1. Керниган, Б. and Ритчи, Д., 2007. [Язык программирования Си= The C programming language](http://dushanov.narod.ru/books/c/C-ru.pdf).—2-е изд. М.: Вильямс
 2. Гриффитс, Гриффитс: Изучаем программирование на C, - М. Эксмо, 2013. - С. 77 - 139
 3. Клеменс Бен, [Язык С в XXI веке](http://orkish5.tplinkdns.com:8080/books/C;C++/%D0%AF%D0%B7%D1%8B%D0%BA%20%D0%A1%20%D0%B2%20XXI%20%D0%B2%D0%B5%D0%BA%D0%B5.pdf) / Пep. с англ. А. А. Слинкина. - М.: ДМК Пресс, 2015. - С. 136 - 152 (глава 6 "Ваш приятель - указатель") 
