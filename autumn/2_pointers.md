# Основы языка C: указатели, работа с памятью

## Указатели

Указатель – это переменная, содержащая адрес другой переменной. Задать указатель можно с помощью оператора **разыменовывания** `*`:

```sh
<тип данных переменной, на которую будет указывать указатель> * <имя указателя>;
```

Например, так:

```c
float *a; # указатель на число с плавающей точкой
int *b; # указатель на целое число 
```

Получить адрес переменной можно с помощью оператора **взятия адреса** `&`:

```c
int A = 100; # целочисленная переменная
int *p; # указатель на целочисленную переменную
p = &A; # присвоение указателю адреса пременной А
```

В качестве примера из реальной жизни переменную `int A` можно представлять, допустим, как дом, а переменную `int *p` - как адрес этого дома. 

<img src="https://habrastorage.org/webt/qv/_-/8g/qv_-8gzavf58hfrkpz2qkqle26s.png" width="600"/>

*Рис. 1. Аналогия из реальной жизни для понятия указатель.*

Оперируя указателями, вы подсказываете вычислительной машине, где взть данные, вместо того, чтобы заставлять ее эти данные постоянно копировать. Такой подход значительно ускоряет время выполнения программ.

Отметим важную деталь: **указатель всегда хранит адрес первого байта пременной!** 

Как же тогда электронная вычислительная машина (ЭВМ) понимает, сколько байт нужно будет взять по указанному адресу? Тип данных переменной, адрес которой хранится в качестве указателя, явно сообщает ЭВМ, сколько байт эта переменная будет занимать. Соответвенно, зная адрес первого байта, хранящегося в качестве указателя, ЭВМ без труда отсчитывает нужное ей количество байт, соответсующее типу данных. 

## Массивы

В языке С массивы задаются с помощью следующего синтаксиса:

```sh
<тип данных элементов> <имя массива>[<максимальное количество элементов>];
```

Приведем пример:

```c
int arr[100] = {1, 2, 3};
```

Непосредственно переменная ```arr``` хранит первый байт первого элемента. Однако, когда вы захотите распечатать элемент массива по индексу (допустим, с помощью функции `printf("%d", arr[1])`), ЭВМ распознает квадратные скобки, поймет, что вы имеете ввиду массив и в данном случае выведет вам 2.

"Под капотом" `arr[1]` равносильно `arr + 1`. Иначе говоря, обращение по индексу - это сдвиг от первого байта первого элемента на номер индекса умноженного на размер одного элемента в байтах.  **Именно поэтому индексация во всех Си-подобных языках начинается с нуля!** Такой подход к рассмотрению индексов и указателей называется *адресной арифметикой*.

> Может показаться странным, но такая запись тоже будет верной:
>
> ```c
>  1[a]
> ```
> В данном случае работает знакомое арифметическое правило - от престановки слагаемых сумма не меняется: 
>
> `a[1] = a + 1 = 1 + a = 1[a]`.
>
> Однако, в целях сохранения читаемости такой код лучше не писать.

## Строки

В языке С строки – это массивы символов (`char`).

Задавать их можно либо с помощью указателей:

```c
char * str = “Hello, World!”;
```

Либо с помощью синтаксиса массивов:

```c
char str[256] = “Hello, World!”;
```

Две эти записи **не** равносильны между собой с точки зрения обращения к памяти, но об этом позже.

В памяти строка представляет примерно следующий вид (рис. 2):

<img src="https://habrastorage.org/webt/qj/ry/n_/qjryn_0umklcsrowqpsp3ey7b90.png" width="600"/>

*Рис. 2. Представление строк языка С в памяти.*

Обратите внимание на последний символ: `\0` - именно по нему ЭВМ понимает, что строка окончена.

## Указатели и структуры

Указатели могут указывать и на структуры. 

Допустим, у нас есть структура следующего вида:

```c
struct point{
int x;
int y;
};
```

Указатель на такую структуру будет выглядеть следующим образом:

```c
struct point * p_point;
```

Обращение к элементам структуры через указатель осуществляется с помощью оператора `->` (рис. 3):

<img src="https://habrastorage.org/webt/ls/im/rg/lsimrgddskmkk8v8dccktkvst30.png" width="600"/>

*Рис. 3. Скрин-шот примера работы со структурами напрямую и через указатели.*
