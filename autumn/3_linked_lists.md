# Основы алгоритмов и структур данных: добавление элемента в начало односвязного списка

## Введение

Связные списки - это одна из основных линейных структур данных, которая хорошо подходит для того, чтобы:
- узнать о плюсах и минусах массивов (через сравнение);
- проверить ваши навыки владения языком Си (см. ["Почему на собеседованиях так часто спрашивают про связные списки
"](https://habr.com/ru/post/455070/));
- познакомиться со структурой данных, с которой связана тема вырождения двоичных деревьев поиска;
- познакомиться со структурой данных, на основе которой построены реализации других линейных структур данных (см. ["How to Implement a Python Stack
"](https://realpython.com/how-to-implement-python-stack/)).

Сегодня мы разберем тему односвязных связных списков, а именно добавление элемента в начало списка. За основу возьмем данный учебный материал:
> [Односвязный список](https://learnc.info/adt/linked_list.html)

## Создание односвязного списка

Итак, для начала создадим структуру, которая будет описывать любой из узлов связного списка:

```c

typedef struct Node {
    int value;
    struct Node *next;
} Node;

```

То есть каждый узел хранит целочисленное значение и "знает" адрес следующего узла. 

Теперь зададим и сам связный список, проинициализировав его головной узел (выделим память динамически):

```c

typedef struct Node {
    int value;
    struct Node *next;
} Node;

int main(){
  Node *head = (Node*) malloc(sizeof(Node)); // указатель, по которому можно найти головной элемент
  head->value = 4; // добавим значение в головной узел
  return 0;
}
```

## Добавление элемента в начало односвязного списка

Напишем функцию, которая будет добавлять элементы в начало нашего списка ("вталкивать" их):

```c
void push(Node **head, int data) {
    Node *tmp = (Node*) malloc(sizeof(Node));
    tmp->value = data;
    tmp->next = (*head);
    (*head) = tmp;
}

```

и разберем построчно, что же в ней происходит.

1. Для нового узла создается **локальная** переменная `tmp`.

```c
Node *tmp = (Node*) malloc(sizeof(Node));
```

Сама переменная `tmp` является локальной, а значит ее значение будет очищено после прекращения работы функции. Однако, `tmp` - это еще и указатель, направленный с помощью функции `malloc()` на область памяти под названием куча. Запомним это.

2. По указателю на структуру типа `Node` добавляем в поле `value` значение, принятое через аргумент функции `push()`.

```c
tmp->value = data;
```

Получаем примерно следующую картину:

![](https://habrastorage.org/webt/hi/_y/ei/hi_yei3bpdsrunn2oiuukyywlno.png)

3. Далее направляем новую ячейку на ту, что мы раньше назвали головной.

```c
tmp->next = (*head);
```

![](https://habrastorage.org/webt/f3/dm/hk/f3dmhknz6vxbmbxon5uumfvtcqe.png)

Связный список почти готов. 

4. Как мы помним, переменная `tmp` локальная, и поэтому она "уничтожится" после того, как функция закончит свою работу. Более того, чтобы обратиться к односвязному списку мы должны знать что является его головным узлом. Чтобы не потерять новый узел и с него же начинать отсчет списка делаем следующее:

```c
(*head) = tmp;
```

Напоминаю, что в качестве аргумента мы передавали **указатель на указатель** (`Node **head`), а значит операция разыменовывания (`(*head)`) отдаст нам указатель. В нашем случае указатель на головной элемент. Присваевая ему новый адрес, мы запоминаем этот адрес вне локальной видимости функции `push()`.

![](https://habrastorage.org/webt/ud/ol/5d/udol5dpcee-fdyb6uiyvkb3j0_0.png)

## Итоговый вид программы

Проверим корректность выполнения функции:

```c
// main.c

#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int value;
    struct Node *next;
} Node;

void push(Node **head, int data) {
    Node *tmp = (Node*) malloc(sizeof(Node));
    tmp->value = data;
    tmp->next = (*head);
    (*head) = tmp;
}

int main(){
  Node *head = (Node*) malloc(sizeof(Node)); // указатель, по которому можно найти головной элемент
  head->value = 4;
  printf("Old head value: %d\n", head->value);

  push(&head, 5);
  printf("New head value: %d\n", head->value);

  return 0;
}
```

На выходе получим:

```sh
$ gcc main.c -o main
$ ./main
Old head value: 4
New head value: 5
```

Работает! 

## Продолжение темы

Вопросы добавления в нужную позицию связного списка, удаления из связного списка, нахождения элемента по значению и сортировки связных списков будут разобраны вами в ходе Лабораторной работы №2.


## Литература

1. Стивенс, Р., 2016. Алгоритмы. Разработка и применение. М.: Издательство «Э. - с. 72-96
2. Седжвик, Р., 2001. Фундаментальные алгоритмы на С++. К.: Диасофт. - 94-111
